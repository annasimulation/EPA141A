#
# Policy Vulnerability
#
# After the MORDM analysis has run, the preferred policy has been selected. The python file [used for simulation](./dike_model_simulation.py) has been copied to create experiments from the preferred policy. This has happened in [the bestpolicy_dike_simulation.py file](./Bestpolicy_dike_model_simulation.py).
#
# Consequently, these experiments are used for the prim analysis. As described in the report, the PRIM analysis is performed in the end of the analysis cycle to test the vulnerability of the selected policy and create an advice for our client which scenarios to be attentive on and in which scenarios the policy will not create the wished for outcomes.
#
#import
from ema_workbench import(
    Model,
    RealParameter,
    ScalarOutcome,
    IntegerParameter,
    CategoricalParameter)
from ema_workbench.analysis import prim
from dike_model_function import DikeNetwork
from ema_workbench.util import ema_logging
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import os
from problem_formulation import (
    sum_over,
    get_model_for_problem_formulation,
    )

ema_logging.log_to_stderr(ema_logging.INFO)

# the function get_model_for_problem_formulation is retrieved from the problem_formulation python file
problem_formulation_id = 6
dike_model, planning_steps = get_model_for_problem_formulation(problem_formulation_id=6)

experiments = pd.read_csv('output/experiments_bestpolicy.csv')
outcomes = pd.read_csv('output/outcomes_bestpolicy.csv')

# the outcomes of 'expected annual damage' and 'dike investment costs' are defined as outcomes of interest.
outcomes_of_interest = ['Expected Annual Damage', 'Dike Investment Costs']
ooi = outcomes_of_interest[0]

# the 4th quantile of the outcomes of interest are defined
# the plot shows the vulnerability of the outcomes of interest

N = experiments.shape[0]

fig, axs = plt.subplots(2, 2, figsize=(12, 8))
for col, ax in zip(outcomes_of_interest, axs.ravel()):
    df = pd.DataFrame()
    df[col] = outcomes[col]
    df['policy'] = experiments['policy']
    df = df.sort_values(by=col, ascending=True)
    df['y'] = np.arange(N) / N
    df = df.reset_index()

    sns.scatterplot(data=df, x=col, y='y', hue='policy',
                    legend=True, linewidth=0,
                    alpha=0.4, palette='tab10', ax=ax)

    q3 = int(N * 0.75)
    ax.axhline(q3 / N, color='k', alpha=0.1, ls='--')
    ax.axvline(df[col][q3], label=str(df[col][q3]),
               color='r', alpha=0.4)

    annotation_point = int(N * 0.61) / N
    if col.split('_')[-1] == 'EAD':
        ax.annotate(text=f"75th percentile:\n{df[col][q3]:.5f}",
                    xy=(df[col][q3], annotation_point),
                    xytext=(3, 0), textcoords='offset pixels')
    else:
        ax.annotate(text=f"75th percentile:\n{df[col][q3]:.0f}",
                    xy=(df[col][q3], annotation_point),
                    xytext=(3, 0), textcoords='offset pixels')

    sns.despine(ax=ax)
    col_name = ' '.join(col.split('_'))
    ax.set(xlabel=col_name, ylabel='Cumulative Probability', ylim=[0, 1.125])
    ax.set_title(f'Distribution of {col_name}')

plt.suptitle('Distribution of outcomes of interest', fontsize=18, y=0.95)
plt.tight_layout(rect=[0, 0, 1, 0.92])
plt.savefig('img/vulnerability_bestpolicy.png')
plt.show()

#As the dike investment costs are defined for the preferred policy, the PRIM analysis is begin performed on the outcome variable *Expected Annual Damage*.
# The PRIM analysis will test the policy for vulnerability and will in the end results in the 5 worst case scenarios that will be included in the advice for our client.

# the experiments and outcomes from the simulation are read.
data = pd.read_csv('output/experiments_and_outcomes.csv')

# the outcome of interest
outcome_variable = 'Expected Annual Damage'

#defining performance threshold as the 4th quantile of the outcome of interest
performance_threshold = data[outcome_variable].quantile(0.75)

# PRIM Analysis
prim_alg = prim.Prim(data, data[outcome_variable] > performance_threshold, threshold=0.75)
box1 = prim_alg.find_box()

#tradeoffs are plotted
box1.show_tradeoff()

plt.hlines(y=[0.80], xmin=0, xmax=1.2, colors='k', alpha=0.5)
plt.vlines(x=[0.80], ymin=0, ymax=1.2, colors='k', alpha=0.5)
plt.title('Tradeoff of Coverage and Density in PRIM')
plt.savefig('img/vulnerability_prim_trajectory.png')
plt.show()

n= 25
box1.show_tradeoff(annotated=True)
box1.inspect(n)
box1.inspect(n, style="graph")
box1.show_pairs_scatter(n)

plt.savefig('img/tradeoff_prim_trajectory.png')
plt.show()

#As the subspace has been defined for the *Expected Annual Damage*, we want to extract the 5 worst case scenarios to give an advice for the client that has a structure for clear communication.

candidates = box1.peeling_trajectory
candidates = candidates[(candidates.coverage > 0.8)
        & (candidates.density > 0.8)]
print(candidates.head(20))

worst_case = candidates[candidates.coverage == candidates.coverage.max()]

worst_case_idx = int(worst_case.index[0])

box1.select(worst_case_idx)
print(worst_case_idx)

sns.set_style('whitegrid')

box1.inspect(style="graph", ticklabel_formatter='{}', boxlim_formatter='{:.2g}')

plt.title('Box with worst case scenarios')
plt.savefig('img/worst_case_bound.png')
plt.show()

box1.show_pairs_scatter()
plt.savefig('img/worst_case_scatter.png')
plt.show()

limit = box1.box_lims[worst_case_idx]
limit

combined_df = experiments.copy()
for key in outcomes:
    combined_df[key] = outcomes[key]

combined_df['Within Limit'] = True

#print(combined_df.shape)
#combined_df.head(5)

# the scenarios within the limits are selected
for idx, row in combined_df.iterrows():
    for unc in limit:
        if (type(limit.loc[0, unc]) == set):
            if row[unc] not in limit.loc[0, unc]:
                combined_df.at[idx, 'Within Limit'] = False
        else:
            if row[unc] < limit.loc[0, unc] or row[unc] > limit.loc[1, unc]:
                combined_df.at[idx, 'Within Limit'] = False

combined_df = combined_df[combined_df['Within Limit']]
combined_df = combined_df.drop(['Within Limit'], axis=1)
print(f'{combined_df.shape[0]} scenarios in the PRIM box.')

combined_df = combined_df.sort_values(by=ooi, ascending=False)
combined_df.head()

# the 5 worst case scenarios are defined and saved to a csv file for further use.
worst_5 = combined_df.head(5)

worst_5.to_csv('output/worst_5_case_scenarios.csv', index=False)

#print(worst_5)